---
layout: post
title: JS 24 OOP
---

<br><br>

## Object-Oriented Programming

<br>

객체 지향 프로그래밍?

좀 더 나은 프로그램을 만들기 위한 프로그래밍 패러다임

로직을 stat(상태)와 behave(행위)로 이루어진 객체로 만들고,

이 객체들을 레고처럼 조립해서 하나의 프로그램으로 만드는 것

객체는 variable과 method를 grouping한 단위들

- object<br>
  라틴어 ob(-in the way of) + ject(to throw)<br>
  ~를 향해+던지다 의 의미를 어원으로 가지고<br>
  ~향해 던지는 그 목표, 사물, 물건, 목적

  - subject<br>
    라틴어 sub(-under) + ject(to throw)<br>
    ~아래 던져두다 / 어떠한 것에 '종속된 것'

- orient +ed <br>
  해가뜨는 곳 이라는 라틴어 Oriens 에서 유래함 반대말 occident<br>
  +ed 해가뜨는 곳 을 가리키는 = 목표하는 방향, 지향

- program +ing<br>
  pre(before) + gram(letter)<br>
  미리 써둔 것

```
어떤 웹사이트에서 본문과 댓글을 각각 담당하는 로직이 있다면
서로 연관성이 있는 로직들을 객체라는 단단한 껍질안에 모아둠

         ----------                  ----------
         -  본문  -                  -  댓글  -
         ----------                  ----------
         -  변수  -                  -  변수  -
         - 메서드 -                  - 메서드 -
         ----------                  ----------

세팅해놓은 로직이 쓸만하다? 다른 곳에서도 쓰일 수 있게
다른 곳에서 사용하려고 하니까 문제가 생긴다?
그런 문제들을 해결하기 위한 로직세팅
= 재활용성을 높임
```

<br><br>

### 문법 / 설계

객체지향 프로그래밍 교육의 큰 두가지 갈래

<br>

#### 문법

객체지향을 편하게 할 수 있도록 언어가 제공하는 기능을 익히는 것<br>
그 기능은 if, for문 처럼 문법적인 구성을 가지고 있음<br>
객체를 만드는 법에 대한 학습

<br>

#### 설계

좋은 객체를 만드는 법 = 설계를 잘하는 법<br>
좋은 설계는 현실을 잘 반영해야 하는데, 현실은 복잡<br>
설계는 지식보다는 지혜의 영역이라고 생각 함

- 내가 서있는 역에서 목표로 하는 역에 가려면 어떤 지도선택?<br>

  위성지도, 일반지도, 전철노선도(실체거리), 일반전철노선도<br>

  누구든 일반전철노선도를 참고할 것<br>

  이는 복잡한 현실을 잘 축소해서 설계한 예시

  - abstract(추상화)<br>
    전기회로도에 영감을 얻어서 만들어진 설계

지혜는 추후에 develope하고<br>
먼저 미리 고안해놓은 지혜들을 지식으로써 익히자

<br><br>

### 부품화

<br>

객체의 개념에서 설명한 '재활용성'을 높인다는 것은<br>
객체를 일종의 부품으로서 사용한다는 것

- 초기 pc<br>
  모니터, 본체, 하드디스크, 키보드 = 한개의 완제품<br>
  하나라도 고장나면 통채로 바꾸거나, 수리하기가 까다로워 짐<br>

  이런 문제를 해결하기 위해 pc를 추상화

  - 본체 : main board, power, hard-disk
  - 출력장치 : monitor
  - 입력장치 : keyboard, mouse

- 현재 pc<br>
  이제 사용자도 비교적 쉽고 저렵하게 고장을 해결할 수 있음

  부품화는 추상화하는 과정에 따라 다르기도 함

  - Apple pc / Microsoft pc

    정답은 없다 <br>
    처한 환경에서 그에 적합한 설계를 하는 것<br>
    but 설계? 쉽지않음

<br>
객체지향은 부품화의 장점

우리가 알고있는 부품화의 예시:method

- method를 부품으로 독립된 프로그램을 만들면<br>
  코드의 양을 줄일 수 있고, method별로 기능이 분류되어 있어<br>
  필요한 코드를 찾기 쉽고, 문제진단이 빨라짐<br>
  method를 개선하면 동일한 method를 사용하는 모든코드가 개선됨

- 다만<br>
  프로그램이 크고 복잡해지면서 method의 양이 많아지면<br>
  method와 variable을 관리하기가 점점 어려워짐<br>
  이를 해결하기위한 방법의 하나가 객체지향 프로그래밍

<br><br>

#### Information hiding | Encapsulation

<br>

제대로된 부품?<br>
그 구조를 몰라도<br>
부품을 사용하는 방법만 알면 쓸 수 있어야 함

- monitor의 원리와 구조를 몰라도<br>
  pc와 monitor를 연결하는 방법만 안다면<br>
  누구나 사용할 수 있어야 함

즉 내부동작 장법을 case안에 숨기고<br>
사용자에게는 부품의 사용방법만을 노출하는 것

<br><br>

#### Interface

<br>

잘 만들어진 부품?<br>
부품과 부품을 교환할 수 있어야 함

- A사와 B사의 monitor가 모두 있다면<br>
  사용자의 pc에 어떤 monitor를 연결하더라도 동작해야 함

- monitor와 pc는 서로 교환관계에 있고<br>
  이를 연결하는 cable의 규격이 표준화 되어있어 가능한 일
  - HDMI cable / LAN cable<br>
    다른기능을 하는 cable간의 물리적 모양을 다르게 만들어<br>
    잘못 꽂지 못하게 설계해 사고를 방지하는 기능도 있음

이런 연결점을 interface라고 하고<br>
이질적인 것들의 결합을 막는 역할도 가지고 있음
= 부품들간의 약속

<br><br>

hardware의 개념에서 살펴본 OOP의 장점들을 기억하면서<br>
software에서 적용되는 OOP를 공부하면 개념을 잡기 쉬울 것

- software는 hardware가 할 수 없는 것들을 할 수 있음<br>
  '복제 / 상속'과 같은 예시가 있다는 것도 숙지하고 공부 할 것
